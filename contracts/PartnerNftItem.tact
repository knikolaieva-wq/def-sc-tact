import "@stdlib/content";

// ===== Messages =====
message(0xb675b483) Transfer {
    query_id: Int as uint64;
    new_owner: Address;
    response_destination: Address;
    custom_payload: Cell? = null;
    forward_amount: Int as coins;
    forward_payload: Slice as remaining;
}
message(0xca9e378a) BurnFromCollection {}

// ===== Structs =====
struct NftData {
    init: Int;
    index: Int;
    collection_address: Slice;
    owner_address: Slice;
    individual_content: Cell;
}    

contract PartnerNftItem {

    // ==== Storage ====
    collection: Address;       // address of PartnerNftCollection
    owner: Address?;           // owner address, null if burned
    index: Int;      // index in collection
    content: Cell;             // individual content (uri as comment cell)
    shareBps: Int;   // 0..10000
    // successfulTxCount will be stored in collection (as you have now), to avoid going to item

    // ==== Error codes ====
    const ExitCodeNonTransferable: Int = 1001;

    // ==== Init ====
    init(
        collection: Address,
        owner: Address,
        index: Int,
        uri: String,
        shareBps: Int
    ) {
        self.collection = collection;
        self.owner = owner;
        self.index = index;
        self.content = createOffchainContent(uri);
        self.shareBps = shareBps;
    }

    // ==== Internal helpers ====
    inline fun onlyCollection() {
        require(sender() == self.collection, "NOT_COLLECTION");
    }    
    
    // ==== Receives ====
    receive() { 
        cashback(sender()) 
    }
    receive(msg: Transfer) { 
        throw(self.ExitCodeNonTransferable); // Non-transferable NFT error code
    }

    // Signal from collection to burn (if you want to actually destroy the contract)
    receive(msg: BurnFromCollection) {
        self.onlyCollection();
        // Either just mark as uninitialized:
        self.owner = null;
        // Or completely shut down the contract:
        //selfdestruct(self.collection);
    }

    // ==== TEP-62 mandatory get-method ====
    get fun get_nft_data(): NftData {
        let initFlag: Int = self.owner == null ? 0 : 1;
        let ownerSlice: Slice = self.owner == null
            ? newAddress(0, 0).asSlice()
            : self.owner!!.asSlice();

        return NftData{
            init: initFlag,
            index: self.index,
            collection_address: self.collection.asSlice(),
            owner_address: ownerSlice,
            individual_content: self.content
        };
    }

    // ==== Additional getters ====
    get fun get_share_bps(): Int {
        return self.shareBps;
    }

    get fun get_owner(): Address? {
        return self.owner;
    }

    get fun get_index(): Int {
        return self.index;
    }

    get fun get_content(): Cell {
        return self.content;
    }
}